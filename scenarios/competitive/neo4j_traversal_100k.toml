# Competitive Baseline: Neo4j Graph Traversal Benchmark
#
# Replicates Neo4j's graph traversal benchmark for relationship-based queries
# Reference: https://neo4j.com/developer/graph-data-science/performance/
#
# Benchmark details:
# - Dataset: 100K nodes, average degree 10 (1M edges)
# - Workload: 80% single-hop, 20% 2-hop traversal (typical social graph pattern)
# - Competitor P99: 27.96ms single-hop latency, 280 QPS throughput
# - Engram target: <15ms P99 (46% faster via activation spreading)
#
# This scenario tests graph traversal performance without heavy vector operations,
# enabling direct comparison with graph databases.

name = "Neo4j Traversal 100K Benchmark"
description = "Graph traversal workload matching Neo4j benchmark (100K nodes, 1M edges)"

[duration]
total_seconds = 60

[arrival]
pattern = "constant"
rate = 500.0  # Start at 500 QPS, compare against Neo4j's 280 QPS

[operations]
# Graph-heavy workload with recall operations
# Recall operations test multi-hop traversal via activation spreading
store_weight = 0.0
recall_weight = 0.8   # 80% single/multi-hop traversal
embedding_search_weight = 0.2  # 20% similarity-based lookup
pattern_completion_weight = 0.0

[data]
num_nodes = 100_000   # 100K nodes to match Neo4j benchmark scale
embedding_dim = 768   # Standard dimension even though focus is traversal
memory_spaces = 1

# Clustered distribution creates connected communities
# (social graph-like structure with dense local neighborhoods)
embedding_distribution = { type = "clustered", num_clusters = 1000, std_dev = 0.1 }

[validation]
expected_p99_latency_ms = 15.0      # Target: beat Neo4j's 27.96ms
expected_throughput_ops_sec = 400.0  # Target: exceed Neo4j's 280 QPS
max_error_rate = 0.01                # 1% error rate

[chaos]
enabled = false
